Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    EQUAL
    MINUS
    DOT
    COMMENT
    TRANSPOSE
    COLON
    FUNCTION
    ATOM

Grammar

Rule 0     S' -> program
Rule 1     program -> cvxbegin statements objective statements cvxend
Rule 2     program -> cvxbegin statements objective cvxend
Rule 3     program -> empty
Rule 4     empty -> <empty>
Rule 5     objective -> SENSE posy NL
Rule 6     objective -> SENSE posy NL SUBJECT TO NL
Rule 7     objective -> SENSE mono NL
Rule 8     objective -> SENSE mono NL SUBJECT TO NL
Rule 9     cvxbegin -> CVX_BEGIN GP SEMICOLON
Rule 10    cvxbegin -> CVX_BEGIN GP COMMA
Rule 11    cvxbegin -> CVX_BEGIN GP NL
Rule 12    cvxend -> CVX_END
Rule 13    cvxend -> CVX_END NL
Rule 14    cvxend -> CVX_END SEMICOLON
Rule 15    cvxend -> CVX_END COMMA
Rule 16    create -> VARIABLE var
Rule 17    create -> VARIABLES varlist
Rule 18    create -> DUAL VARIABLE ID
Rule 19    create -> DUAL VARIABLES idlist
Rule 20    var -> ID LPAREN dimlist RPAREN
Rule 21    var -> ID
Rule 22    var -> ID LPAREN RPAREN
Rule 23    varlist -> varlist var
Rule 24    varlist -> var
Rule 25    dimlist -> INT
Rule 26    dimlist -> ID
Rule 27    idlist -> idlist ID
Rule 28    idlist -> ID
Rule 29    statements -> statement NL
Rule 30    statements -> statement SEMICOLON
Rule 31    statements -> statement COMMA
Rule 32    statements -> statements statement NL
Rule 33    statements -> statements statement SEMICOLON
Rule 34    statements -> statements statement COMMA
Rule 35    statements -> statements statement SEMICOLON NL
Rule 36    statement -> constraint
Rule 37    statement -> create
Rule 38    statement -> chained_constraint
Rule 39    statement -> empty
Rule 40    chained_constraint -> posy LESSTHANEQUAL mono GREATERTHANEQUAL posy
Rule 41    chained_constraint -> mono GREATERTHANEQUAL posy LESSTHANEQUAL mono
Rule 42    chained_constraint -> mono LOGICALEQUAL mono GREATERTHANEQUAL posy
Rule 43    chained_constraint -> posy LESSTHANEQUAL mono LOGICALEQUAL mono
Rule 44    chained_constraint -> mono LESSTHANEQUAL posy GREATERTHANEQUAL mono
Rule 45    chained_constraint -> mono LESSTHANEQUAL mono GREATERTHANEQUAL mono
Rule 46    chained_constraint -> mono LESSTHANEQUAL mono LESSTHANEQUAL mono
Rule 47    constraint -> mono LOGICALEQUAL mono
Rule 48    constraint -> posy LESSTHANEQUAL mono
Rule 49    constraint -> mono GREATERTHANEQUAL posy
Rule 50    constraint -> mono LESSTHANEQUAL mono
Rule 51    constraint -> mono GREATERTHANEQUAL mono
Rule 52    mono -> mono TIMES mono
Rule 53    mono -> mono DIVIDE mono
Rule 54    mono -> mono POWER FLOAT
Rule 55    mono -> mono POWER INT
Rule 56    mono -> var
Rule 57    mono -> INT
Rule 58    mono -> FLOAT
Rule 59    posy -> mono PLUS mono
Rule 60    posy -> posy PLUS posy
Rule 61    posy -> posy PLUS mono
Rule 62    posy -> posy TIMES posy
Rule 63    posy -> posy TIMES mono
Rule 64    posy -> mono TIMES posy
Rule 65    posy -> posy DIVIDE mono
Rule 66    posy -> posy POWER INT
Rule 67    posy -> LPAREN posy RPAREN
Rule 68    mono -> LPAREN mono RPAREN

Terminals, with rules where they appear

ATOM                 : 
COLON                : 
COMMA                : 10 15 31 34
COMMENT              : 
CVX_BEGIN            : 9 10 11
CVX_END              : 12 13 14 15
DIVIDE               : 53 65
DOT                  : 
DUAL                 : 18 19
EQUAL                : 
FLOAT                : 54 58
FUNCTION             : 
GP                   : 9 10 11
GREATERTHANEQUAL     : 40 41 42 44 45 49 51
ID                   : 18 20 21 22 26 27 28
INT                  : 25 55 57 66
LESSTHANEQUAL        : 40 41 43 44 45 46 46 48 50
LOGICALEQUAL         : 42 43 47
LPAREN               : 20 22 67 68
MINUS                : 
NL                   : 5 6 6 7 8 8 11 13 29 32 35
PLUS                 : 59 60 61
POWER                : 54 55 66
RPAREN               : 20 22 67 68
SEMICOLON            : 9 14 30 33 35
SENSE                : 5 6 7 8
SUBJECT              : 6 8
TIMES                : 52 62 63 64
TO                   : 6 8
TRANSPOSE            : 
VARIABLE             : 16 18
VARIABLES            : 17 19
error                : 

Nonterminals, with rules where they appear

chained_constraint   : 38
constraint           : 36
create               : 37
cvxbegin             : 1 2
cvxend               : 1 2
dimlist              : 20
empty                : 3 39
idlist               : 19 27
mono                 : 7 8 40 41 41 42 42 43 43 44 44 45 45 45 46 46 46 47 47 48 49 50 50 51 51 52 52 53 53 54 55 59 59 61 63 64 65 68
objective            : 1 2
posy                 : 5 6 40 40 41 42 43 44 48 49 60 60 61 62 62 63 64 65 66 67
program              : 0
statement            : 29 30 31 32 33 34 35
statements           : 1 1 2 32 33 34 35
var                  : 16 23 24 56
varlist              : 17 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . cvxbegin statements objective statements cvxend
    (2) program -> . cvxbegin statements objective cvxend
    (3) program -> . empty
    (9) cvxbegin -> . CVX_BEGIN GP SEMICOLON
    (10) cvxbegin -> . CVX_BEGIN GP COMMA
    (11) cvxbegin -> . CVX_BEGIN GP NL
    (4) empty -> .

    CVX_BEGIN       shift and go to state 2
    $end            reduce using rule 4 (empty -> .)

    program                        shift and go to state 1
    cvxbegin                       shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (9) cvxbegin -> CVX_BEGIN . GP SEMICOLON
    (10) cvxbegin -> CVX_BEGIN . GP COMMA
    (11) cvxbegin -> CVX_BEGIN . GP NL

    GP              shift and go to state 5


state 3

    (1) program -> cvxbegin . statements objective statements cvxend
    (2) program -> cvxbegin . statements objective cvxend
    (29) statements -> . statement NL
    (30) statements -> . statement SEMICOLON
    (31) statements -> . statement COMMA
    (32) statements -> . statements statement NL
    (33) statements -> . statements statement SEMICOLON
    (34) statements -> . statements statement COMMA
    (35) statements -> . statements statement SEMICOLON NL
    (36) statement -> . constraint
    (37) statement -> . create
    (38) statement -> . chained_constraint
    (39) statement -> . empty
    (47) constraint -> . mono LOGICALEQUAL mono
    (48) constraint -> . posy LESSTHANEQUAL mono
    (49) constraint -> . mono GREATERTHANEQUAL posy
    (50) constraint -> . mono LESSTHANEQUAL mono
    (51) constraint -> . mono GREATERTHANEQUAL mono
    (16) create -> . VARIABLE var
    (17) create -> . VARIABLES varlist
    (18) create -> . DUAL VARIABLE ID
    (19) create -> . DUAL VARIABLES idlist
    (40) chained_constraint -> . posy LESSTHANEQUAL mono GREATERTHANEQUAL posy
    (41) chained_constraint -> . mono GREATERTHANEQUAL posy LESSTHANEQUAL mono
    (42) chained_constraint -> . mono LOGICALEQUAL mono GREATERTHANEQUAL posy
    (43) chained_constraint -> . posy LESSTHANEQUAL mono LOGICALEQUAL mono
    (44) chained_constraint -> . mono LESSTHANEQUAL posy GREATERTHANEQUAL mono
    (45) chained_constraint -> . mono LESSTHANEQUAL mono GREATERTHANEQUAL mono
    (46) chained_constraint -> . mono LESSTHANEQUAL mono LESSTHANEQUAL mono
    (4) empty -> .
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    VARIABLE        shift and go to state 15
    VARIABLES       shift and go to state 21
    DUAL            shift and go to state 7
    NL              reduce using rule 4 (empty -> .)
    SEMICOLON       reduce using rule 4 (empty -> .)
    COMMA           reduce using rule 4 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 13
    ID              shift and go to state 16

    statements                     shift and go to state 6
    constraint                     shift and go to state 17
    mono                           shift and go to state 19
    create                         shift and go to state 8
    var                            shift and go to state 10
    statement                      shift and go to state 9
    posy                           shift and go to state 14
    chained_constraint             shift and go to state 12
    empty                          shift and go to state 11

state 4

    (3) program -> empty .

    $end            reduce using rule 3 (program -> empty .)


state 5

    (9) cvxbegin -> CVX_BEGIN GP . SEMICOLON
    (10) cvxbegin -> CVX_BEGIN GP . COMMA
    (11) cvxbegin -> CVX_BEGIN GP . NL

    SEMICOLON       shift and go to state 24
    COMMA           shift and go to state 23
    NL              shift and go to state 22


state 6

    (1) program -> cvxbegin statements . objective statements cvxend
    (2) program -> cvxbegin statements . objective cvxend
    (32) statements -> statements . statement NL
    (33) statements -> statements . statement SEMICOLON
    (34) statements -> statements . statement COMMA
    (35) statements -> statements . statement SEMICOLON NL
    (5) objective -> . SENSE posy NL
    (6) objective -> . SENSE posy NL SUBJECT TO NL
    (7) objective -> . SENSE mono NL
    (8) objective -> . SENSE mono NL SUBJECT TO NL
    (36) statement -> . constraint
    (37) statement -> . create
    (38) statement -> . chained_constraint
    (39) statement -> . empty
    (47) constraint -> . mono LOGICALEQUAL mono
    (48) constraint -> . posy LESSTHANEQUAL mono
    (49) constraint -> . mono GREATERTHANEQUAL posy
    (50) constraint -> . mono LESSTHANEQUAL mono
    (51) constraint -> . mono GREATERTHANEQUAL mono
    (16) create -> . VARIABLE var
    (17) create -> . VARIABLES varlist
    (18) create -> . DUAL VARIABLE ID
    (19) create -> . DUAL VARIABLES idlist
    (40) chained_constraint -> . posy LESSTHANEQUAL mono GREATERTHANEQUAL posy
    (41) chained_constraint -> . mono GREATERTHANEQUAL posy LESSTHANEQUAL mono
    (42) chained_constraint -> . mono LOGICALEQUAL mono GREATERTHANEQUAL posy
    (43) chained_constraint -> . posy LESSTHANEQUAL mono LOGICALEQUAL mono
    (44) chained_constraint -> . mono LESSTHANEQUAL posy GREATERTHANEQUAL mono
    (45) chained_constraint -> . mono LESSTHANEQUAL mono GREATERTHANEQUAL mono
    (46) chained_constraint -> . mono LESSTHANEQUAL mono LESSTHANEQUAL mono
    (4) empty -> .
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    SENSE           shift and go to state 27
    VARIABLE        shift and go to state 15
    VARIABLES       shift and go to state 21
    DUAL            shift and go to state 7
    NL              reduce using rule 4 (empty -> .)
    SEMICOLON       reduce using rule 4 (empty -> .)
    COMMA           reduce using rule 4 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 13
    ID              shift and go to state 16

    constraint                     shift and go to state 17
    mono                           shift and go to state 19
    create                         shift and go to state 8
    var                            shift and go to state 10
    objective                      shift and go to state 26
    statement                      shift and go to state 25
    posy                           shift and go to state 14
    chained_constraint             shift and go to state 12
    empty                          shift and go to state 11

state 7

    (18) create -> DUAL . VARIABLE ID
    (19) create -> DUAL . VARIABLES idlist

    VARIABLE        shift and go to state 28
    VARIABLES       shift and go to state 29


state 8

    (37) statement -> create .

    NL              reduce using rule 37 (statement -> create .)
    SEMICOLON       reduce using rule 37 (statement -> create .)
    COMMA           reduce using rule 37 (statement -> create .)


state 9

    (29) statements -> statement . NL
    (30) statements -> statement . SEMICOLON
    (31) statements -> statement . COMMA

    NL              shift and go to state 31
    SEMICOLON       shift and go to state 32
    COMMA           shift and go to state 30


state 10

    (56) mono -> var .

    RPAREN          reduce using rule 56 (mono -> var .)
    TIMES           reduce using rule 56 (mono -> var .)
    DIVIDE          reduce using rule 56 (mono -> var .)
    POWER           reduce using rule 56 (mono -> var .)
    NL              reduce using rule 56 (mono -> var .)
    SEMICOLON       reduce using rule 56 (mono -> var .)
    COMMA           reduce using rule 56 (mono -> var .)
    LOGICALEQUAL    reduce using rule 56 (mono -> var .)
    GREATERTHANEQUAL reduce using rule 56 (mono -> var .)
    LESSTHANEQUAL   reduce using rule 56 (mono -> var .)
    PLUS            reduce using rule 56 (mono -> var .)


state 11

    (39) statement -> empty .

    NL              reduce using rule 39 (statement -> empty .)
    SEMICOLON       reduce using rule 39 (statement -> empty .)
    COMMA           reduce using rule 39 (statement -> empty .)


state 12

    (38) statement -> chained_constraint .

    NL              reduce using rule 38 (statement -> chained_constraint .)
    SEMICOLON       reduce using rule 38 (statement -> chained_constraint .)
    COMMA           reduce using rule 38 (statement -> chained_constraint .)


state 13

    (68) mono -> LPAREN . mono RPAREN
    (67) posy -> LPAREN . posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 13
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 33
    posy                           shift and go to state 34

state 14

    (48) constraint -> posy . LESSTHANEQUAL mono
    (40) chained_constraint -> posy . LESSTHANEQUAL mono GREATERTHANEQUAL posy
    (43) chained_constraint -> posy . LESSTHANEQUAL mono LOGICALEQUAL mono
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    LESSTHANEQUAL   shift and go to state 37
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 35
    POWER           shift and go to state 36


state 15

    (16) create -> VARIABLE . var
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    ID              shift and go to state 16

    var                            shift and go to state 40

state 16

    (20) var -> ID . LPAREN dimlist RPAREN
    (21) var -> ID .
    (22) var -> ID . LPAREN RPAREN

    LPAREN          shift and go to state 41
    TIMES           reduce using rule 21 (var -> ID .)
    DIVIDE          reduce using rule 21 (var -> ID .)
    POWER           reduce using rule 21 (var -> ID .)
    PLUS            reduce using rule 21 (var -> ID .)
    LOGICALEQUAL    reduce using rule 21 (var -> ID .)
    GREATERTHANEQUAL reduce using rule 21 (var -> ID .)
    LESSTHANEQUAL   reduce using rule 21 (var -> ID .)
    RPAREN          reduce using rule 21 (var -> ID .)
    NL              reduce using rule 21 (var -> ID .)
    SEMICOLON       reduce using rule 21 (var -> ID .)
    COMMA           reduce using rule 21 (var -> ID .)
    ID              reduce using rule 21 (var -> ID .)


state 17

    (36) statement -> constraint .

    NL              reduce using rule 36 (statement -> constraint .)
    SEMICOLON       reduce using rule 36 (statement -> constraint .)
    COMMA           reduce using rule 36 (statement -> constraint .)


state 18

    (57) mono -> INT .

    RPAREN          reduce using rule 57 (mono -> INT .)
    TIMES           reduce using rule 57 (mono -> INT .)
    DIVIDE          reduce using rule 57 (mono -> INT .)
    POWER           reduce using rule 57 (mono -> INT .)
    NL              reduce using rule 57 (mono -> INT .)
    SEMICOLON       reduce using rule 57 (mono -> INT .)
    COMMA           reduce using rule 57 (mono -> INT .)
    LOGICALEQUAL    reduce using rule 57 (mono -> INT .)
    GREATERTHANEQUAL reduce using rule 57 (mono -> INT .)
    LESSTHANEQUAL   reduce using rule 57 (mono -> INT .)
    PLUS            reduce using rule 57 (mono -> INT .)


state 19

    (47) constraint -> mono . LOGICALEQUAL mono
    (49) constraint -> mono . GREATERTHANEQUAL posy
    (50) constraint -> mono . LESSTHANEQUAL mono
    (51) constraint -> mono . GREATERTHANEQUAL mono
    (41) chained_constraint -> mono . GREATERTHANEQUAL posy LESSTHANEQUAL mono
    (42) chained_constraint -> mono . LOGICALEQUAL mono GREATERTHANEQUAL posy
    (44) chained_constraint -> mono . LESSTHANEQUAL posy GREATERTHANEQUAL mono
    (45) chained_constraint -> mono . LESSTHANEQUAL mono GREATERTHANEQUAL mono
    (46) chained_constraint -> mono . LESSTHANEQUAL mono LESSTHANEQUAL mono
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy

    LOGICALEQUAL    shift and go to state 47
    GREATERTHANEQUAL shift and go to state 45
    LESSTHANEQUAL   shift and go to state 44
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43
    PLUS            shift and go to state 48


state 20

    (58) mono -> FLOAT .

    RPAREN          reduce using rule 58 (mono -> FLOAT .)
    TIMES           reduce using rule 58 (mono -> FLOAT .)
    DIVIDE          reduce using rule 58 (mono -> FLOAT .)
    POWER           reduce using rule 58 (mono -> FLOAT .)
    NL              reduce using rule 58 (mono -> FLOAT .)
    SEMICOLON       reduce using rule 58 (mono -> FLOAT .)
    COMMA           reduce using rule 58 (mono -> FLOAT .)
    LOGICALEQUAL    reduce using rule 58 (mono -> FLOAT .)
    GREATERTHANEQUAL reduce using rule 58 (mono -> FLOAT .)
    LESSTHANEQUAL   reduce using rule 58 (mono -> FLOAT .)
    PLUS            reduce using rule 58 (mono -> FLOAT .)


state 21

    (17) create -> VARIABLES . varlist
    (23) varlist -> . varlist var
    (24) varlist -> . var
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    ID              shift and go to state 16

    varlist                        shift and go to state 49
    var                            shift and go to state 50

state 22

    (11) cvxbegin -> CVX_BEGIN GP NL .

    VARIABLE        reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    VARIABLES       reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    DUAL            reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    INT             reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    FLOAT           reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    LPAREN          reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    ID              reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    NL              reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    SEMICOLON       reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)
    COMMA           reduce using rule 11 (cvxbegin -> CVX_BEGIN GP NL .)


state 23

    (10) cvxbegin -> CVX_BEGIN GP COMMA .

    VARIABLE        reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    VARIABLES       reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    DUAL            reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    INT             reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    FLOAT           reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    LPAREN          reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    ID              reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    NL              reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    SEMICOLON       reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)
    COMMA           reduce using rule 10 (cvxbegin -> CVX_BEGIN GP COMMA .)


state 24

    (9) cvxbegin -> CVX_BEGIN GP SEMICOLON .

    VARIABLE        reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    VARIABLES       reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    DUAL            reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    INT             reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    FLOAT           reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    LPAREN          reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    ID              reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    NL              reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    SEMICOLON       reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)
    COMMA           reduce using rule 9 (cvxbegin -> CVX_BEGIN GP SEMICOLON .)


state 25

    (32) statements -> statements statement . NL
    (33) statements -> statements statement . SEMICOLON
    (34) statements -> statements statement . COMMA
    (35) statements -> statements statement . SEMICOLON NL

    NL              shift and go to state 51
    SEMICOLON       shift and go to state 53
    COMMA           shift and go to state 52


state 26

    (1) program -> cvxbegin statements objective . statements cvxend
    (2) program -> cvxbegin statements objective . cvxend
    (29) statements -> . statement NL
    (30) statements -> . statement SEMICOLON
    (31) statements -> . statement COMMA
    (32) statements -> . statements statement NL
    (33) statements -> . statements statement SEMICOLON
    (34) statements -> . statements statement COMMA
    (35) statements -> . statements statement SEMICOLON NL
    (12) cvxend -> . CVX_END
    (13) cvxend -> . CVX_END NL
    (14) cvxend -> . CVX_END SEMICOLON
    (15) cvxend -> . CVX_END COMMA
    (36) statement -> . constraint
    (37) statement -> . create
    (38) statement -> . chained_constraint
    (39) statement -> . empty
    (47) constraint -> . mono LOGICALEQUAL mono
    (48) constraint -> . posy LESSTHANEQUAL mono
    (49) constraint -> . mono GREATERTHANEQUAL posy
    (50) constraint -> . mono LESSTHANEQUAL mono
    (51) constraint -> . mono GREATERTHANEQUAL mono
    (16) create -> . VARIABLE var
    (17) create -> . VARIABLES varlist
    (18) create -> . DUAL VARIABLE ID
    (19) create -> . DUAL VARIABLES idlist
    (40) chained_constraint -> . posy LESSTHANEQUAL mono GREATERTHANEQUAL posy
    (41) chained_constraint -> . mono GREATERTHANEQUAL posy LESSTHANEQUAL mono
    (42) chained_constraint -> . mono LOGICALEQUAL mono GREATERTHANEQUAL posy
    (43) chained_constraint -> . posy LESSTHANEQUAL mono LOGICALEQUAL mono
    (44) chained_constraint -> . mono LESSTHANEQUAL posy GREATERTHANEQUAL mono
    (45) chained_constraint -> . mono LESSTHANEQUAL mono GREATERTHANEQUAL mono
    (46) chained_constraint -> . mono LESSTHANEQUAL mono LESSTHANEQUAL mono
    (4) empty -> .
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    CVX_END         shift and go to state 56
    VARIABLE        shift and go to state 15
    VARIABLES       shift and go to state 21
    DUAL            shift and go to state 7
    NL              reduce using rule 4 (empty -> .)
    SEMICOLON       reduce using rule 4 (empty -> .)
    COMMA           reduce using rule 4 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 13
    ID              shift and go to state 16

    statements                     shift and go to state 54
    constraint                     shift and go to state 17
    mono                           shift and go to state 19
    create                         shift and go to state 8
    var                            shift and go to state 10
    cvxend                         shift and go to state 55
    statement                      shift and go to state 9
    posy                           shift and go to state 14
    chained_constraint             shift and go to state 12
    empty                          shift and go to state 11

state 27

    (5) objective -> SENSE . posy NL
    (6) objective -> SENSE . posy NL SUBJECT TO NL
    (7) objective -> SENSE . mono NL
    (8) objective -> SENSE . mono NL SUBJECT TO NL
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 58
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 57
    posy                           shift and go to state 59

state 28

    (18) create -> DUAL VARIABLE . ID

    ID              shift and go to state 60


state 29

    (19) create -> DUAL VARIABLES . idlist
    (27) idlist -> . idlist ID
    (28) idlist -> . ID

    ID              shift and go to state 62

    idlist                         shift and go to state 61

state 30

    (31) statements -> statement COMMA .

    CVX_END         reduce using rule 31 (statements -> statement COMMA .)
    VARIABLE        reduce using rule 31 (statements -> statement COMMA .)
    VARIABLES       reduce using rule 31 (statements -> statement COMMA .)
    DUAL            reduce using rule 31 (statements -> statement COMMA .)
    INT             reduce using rule 31 (statements -> statement COMMA .)
    FLOAT           reduce using rule 31 (statements -> statement COMMA .)
    LPAREN          reduce using rule 31 (statements -> statement COMMA .)
    ID              reduce using rule 31 (statements -> statement COMMA .)
    NL              reduce using rule 31 (statements -> statement COMMA .)
    SEMICOLON       reduce using rule 31 (statements -> statement COMMA .)
    COMMA           reduce using rule 31 (statements -> statement COMMA .)
    SENSE           reduce using rule 31 (statements -> statement COMMA .)


state 31

    (29) statements -> statement NL .

    CVX_END         reduce using rule 29 (statements -> statement NL .)
    VARIABLE        reduce using rule 29 (statements -> statement NL .)
    VARIABLES       reduce using rule 29 (statements -> statement NL .)
    DUAL            reduce using rule 29 (statements -> statement NL .)
    INT             reduce using rule 29 (statements -> statement NL .)
    FLOAT           reduce using rule 29 (statements -> statement NL .)
    LPAREN          reduce using rule 29 (statements -> statement NL .)
    ID              reduce using rule 29 (statements -> statement NL .)
    NL              reduce using rule 29 (statements -> statement NL .)
    SEMICOLON       reduce using rule 29 (statements -> statement NL .)
    COMMA           reduce using rule 29 (statements -> statement NL .)
    SENSE           reduce using rule 29 (statements -> statement NL .)


state 32

    (30) statements -> statement SEMICOLON .

    CVX_END         reduce using rule 30 (statements -> statement SEMICOLON .)
    VARIABLE        reduce using rule 30 (statements -> statement SEMICOLON .)
    VARIABLES       reduce using rule 30 (statements -> statement SEMICOLON .)
    DUAL            reduce using rule 30 (statements -> statement SEMICOLON .)
    INT             reduce using rule 30 (statements -> statement SEMICOLON .)
    FLOAT           reduce using rule 30 (statements -> statement SEMICOLON .)
    LPAREN          reduce using rule 30 (statements -> statement SEMICOLON .)
    ID              reduce using rule 30 (statements -> statement SEMICOLON .)
    NL              reduce using rule 30 (statements -> statement SEMICOLON .)
    SEMICOLON       reduce using rule 30 (statements -> statement SEMICOLON .)
    COMMA           reduce using rule 30 (statements -> statement SEMICOLON .)
    SENSE           reduce using rule 30 (statements -> statement SEMICOLON .)


state 33

    (68) mono -> LPAREN mono . RPAREN
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy

    RPAREN          shift and go to state 63
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43
    PLUS            shift and go to state 48


state 34

    (67) posy -> LPAREN posy . RPAREN
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    RPAREN          shift and go to state 64
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 35
    POWER           shift and go to state 36


state 35

    (65) posy -> posy DIVIDE . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 65

state 36

    (66) posy -> posy POWER . INT

    INT             shift and go to state 67


state 37

    (48) constraint -> posy LESSTHANEQUAL . mono
    (40) chained_constraint -> posy LESSTHANEQUAL . mono GREATERTHANEQUAL posy
    (43) chained_constraint -> posy LESSTHANEQUAL . mono LOGICALEQUAL mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 68

state 38

    (62) posy -> posy TIMES . posy
    (63) posy -> posy TIMES . mono
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 58
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 69
    posy                           shift and go to state 70

state 39

    (60) posy -> posy PLUS . posy
    (61) posy -> posy PLUS . mono
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 58
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 71
    posy                           shift and go to state 72

state 40

    (16) create -> VARIABLE var .

    NL              reduce using rule 16 (create -> VARIABLE var .)
    SEMICOLON       reduce using rule 16 (create -> VARIABLE var .)
    COMMA           reduce using rule 16 (create -> VARIABLE var .)


state 41

    (20) var -> ID LPAREN . dimlist RPAREN
    (22) var -> ID LPAREN . RPAREN
    (25) dimlist -> . INT
    (26) dimlist -> . ID

    RPAREN          shift and go to state 75
    INT             shift and go to state 73
    ID              shift and go to state 76

    dimlist                        shift and go to state 74

state 42

    (53) mono -> mono DIVIDE . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 77

state 43

    (54) mono -> mono POWER . FLOAT
    (55) mono -> mono POWER . INT

    FLOAT           shift and go to state 79
    INT             shift and go to state 78


state 44

    (50) constraint -> mono LESSTHANEQUAL . mono
    (44) chained_constraint -> mono LESSTHANEQUAL . posy GREATERTHANEQUAL mono
    (45) chained_constraint -> mono LESSTHANEQUAL . mono GREATERTHANEQUAL mono
    (46) chained_constraint -> mono LESSTHANEQUAL . mono LESSTHANEQUAL mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 13
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 80
    posy                           shift and go to state 81

state 45

    (49) constraint -> mono GREATERTHANEQUAL . posy
    (51) constraint -> mono GREATERTHANEQUAL . mono
    (41) chained_constraint -> mono GREATERTHANEQUAL . posy LESSTHANEQUAL mono
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 58
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 82
    posy                           shift and go to state 83

state 46

    (52) mono -> mono TIMES . mono
    (64) posy -> mono TIMES . posy
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 13
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 84
    posy                           shift and go to state 85

state 47

    (47) constraint -> mono LOGICALEQUAL . mono
    (42) chained_constraint -> mono LOGICALEQUAL . mono GREATERTHANEQUAL posy
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 86

state 48

    (59) posy -> mono PLUS . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 87

state 49

    (17) create -> VARIABLES varlist .
    (23) varlist -> varlist . var
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    NL              reduce using rule 17 (create -> VARIABLES varlist .)
    SEMICOLON       reduce using rule 17 (create -> VARIABLES varlist .)
    COMMA           reduce using rule 17 (create -> VARIABLES varlist .)
    ID              shift and go to state 16

    var                            shift and go to state 88

state 50

    (24) varlist -> var .

    ID              reduce using rule 24 (varlist -> var .)
    NL              reduce using rule 24 (varlist -> var .)
    SEMICOLON       reduce using rule 24 (varlist -> var .)
    COMMA           reduce using rule 24 (varlist -> var .)


state 51

    (32) statements -> statements statement NL .

    CVX_END         reduce using rule 32 (statements -> statements statement NL .)
    VARIABLE        reduce using rule 32 (statements -> statements statement NL .)
    VARIABLES       reduce using rule 32 (statements -> statements statement NL .)
    DUAL            reduce using rule 32 (statements -> statements statement NL .)
    INT             reduce using rule 32 (statements -> statements statement NL .)
    FLOAT           reduce using rule 32 (statements -> statements statement NL .)
    LPAREN          reduce using rule 32 (statements -> statements statement NL .)
    ID              reduce using rule 32 (statements -> statements statement NL .)
    NL              reduce using rule 32 (statements -> statements statement NL .)
    SEMICOLON       reduce using rule 32 (statements -> statements statement NL .)
    COMMA           reduce using rule 32 (statements -> statements statement NL .)
    SENSE           reduce using rule 32 (statements -> statements statement NL .)


state 52

    (34) statements -> statements statement COMMA .

    CVX_END         reduce using rule 34 (statements -> statements statement COMMA .)
    VARIABLE        reduce using rule 34 (statements -> statements statement COMMA .)
    VARIABLES       reduce using rule 34 (statements -> statements statement COMMA .)
    DUAL            reduce using rule 34 (statements -> statements statement COMMA .)
    INT             reduce using rule 34 (statements -> statements statement COMMA .)
    FLOAT           reduce using rule 34 (statements -> statements statement COMMA .)
    LPAREN          reduce using rule 34 (statements -> statements statement COMMA .)
    ID              reduce using rule 34 (statements -> statements statement COMMA .)
    NL              reduce using rule 34 (statements -> statements statement COMMA .)
    SEMICOLON       reduce using rule 34 (statements -> statements statement COMMA .)
    COMMA           reduce using rule 34 (statements -> statements statement COMMA .)
    SENSE           reduce using rule 34 (statements -> statements statement COMMA .)


state 53

    (33) statements -> statements statement SEMICOLON .
    (35) statements -> statements statement SEMICOLON . NL

  ! shift/reduce conflict for NL resolved as shift
    CVX_END         reduce using rule 33 (statements -> statements statement SEMICOLON .)
    VARIABLE        reduce using rule 33 (statements -> statements statement SEMICOLON .)
    VARIABLES       reduce using rule 33 (statements -> statements statement SEMICOLON .)
    DUAL            reduce using rule 33 (statements -> statements statement SEMICOLON .)
    INT             reduce using rule 33 (statements -> statements statement SEMICOLON .)
    FLOAT           reduce using rule 33 (statements -> statements statement SEMICOLON .)
    LPAREN          reduce using rule 33 (statements -> statements statement SEMICOLON .)
    ID              reduce using rule 33 (statements -> statements statement SEMICOLON .)
    SEMICOLON       reduce using rule 33 (statements -> statements statement SEMICOLON .)
    COMMA           reduce using rule 33 (statements -> statements statement SEMICOLON .)
    SENSE           reduce using rule 33 (statements -> statements statement SEMICOLON .)
    NL              shift and go to state 89

  ! NL              [ reduce using rule 33 (statements -> statements statement SEMICOLON .) ]


state 54

    (1) program -> cvxbegin statements objective statements . cvxend
    (32) statements -> statements . statement NL
    (33) statements -> statements . statement SEMICOLON
    (34) statements -> statements . statement COMMA
    (35) statements -> statements . statement SEMICOLON NL
    (12) cvxend -> . CVX_END
    (13) cvxend -> . CVX_END NL
    (14) cvxend -> . CVX_END SEMICOLON
    (15) cvxend -> . CVX_END COMMA
    (36) statement -> . constraint
    (37) statement -> . create
    (38) statement -> . chained_constraint
    (39) statement -> . empty
    (47) constraint -> . mono LOGICALEQUAL mono
    (48) constraint -> . posy LESSTHANEQUAL mono
    (49) constraint -> . mono GREATERTHANEQUAL posy
    (50) constraint -> . mono LESSTHANEQUAL mono
    (51) constraint -> . mono GREATERTHANEQUAL mono
    (16) create -> . VARIABLE var
    (17) create -> . VARIABLES varlist
    (18) create -> . DUAL VARIABLE ID
    (19) create -> . DUAL VARIABLES idlist
    (40) chained_constraint -> . posy LESSTHANEQUAL mono GREATERTHANEQUAL posy
    (41) chained_constraint -> . mono GREATERTHANEQUAL posy LESSTHANEQUAL mono
    (42) chained_constraint -> . mono LOGICALEQUAL mono GREATERTHANEQUAL posy
    (43) chained_constraint -> . posy LESSTHANEQUAL mono LOGICALEQUAL mono
    (44) chained_constraint -> . mono LESSTHANEQUAL posy GREATERTHANEQUAL mono
    (45) chained_constraint -> . mono LESSTHANEQUAL mono GREATERTHANEQUAL mono
    (46) chained_constraint -> . mono LESSTHANEQUAL mono LESSTHANEQUAL mono
    (4) empty -> .
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    CVX_END         shift and go to state 56
    VARIABLE        shift and go to state 15
    VARIABLES       shift and go to state 21
    DUAL            shift and go to state 7
    NL              reduce using rule 4 (empty -> .)
    SEMICOLON       reduce using rule 4 (empty -> .)
    COMMA           reduce using rule 4 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 13
    ID              shift and go to state 16

    constraint                     shift and go to state 17
    mono                           shift and go to state 19
    create                         shift and go to state 8
    var                            shift and go to state 10
    cvxend                         shift and go to state 90
    statement                      shift and go to state 25
    posy                           shift and go to state 14
    chained_constraint             shift and go to state 12
    empty                          shift and go to state 11

state 55

    (2) program -> cvxbegin statements objective cvxend .

    $end            reduce using rule 2 (program -> cvxbegin statements objective cvxend .)


state 56

    (12) cvxend -> CVX_END .
    (13) cvxend -> CVX_END . NL
    (14) cvxend -> CVX_END . SEMICOLON
    (15) cvxend -> CVX_END . COMMA

    $end            reduce using rule 12 (cvxend -> CVX_END .)
    NL              shift and go to state 92
    SEMICOLON       shift and go to state 93
    COMMA           shift and go to state 91


state 57

    (7) objective -> SENSE mono . NL
    (8) objective -> SENSE mono . NL SUBJECT TO NL
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              shift and go to state 94
    PLUS            shift and go to state 48
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 58

    (67) posy -> LPAREN . posy RPAREN
    (68) mono -> LPAREN . mono RPAREN
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 58
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 96
    posy                           shift and go to state 34

state 59

    (5) objective -> SENSE posy . NL
    (6) objective -> SENSE posy . NL SUBJECT TO NL
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    NL              shift and go to state 97
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 35
    POWER           shift and go to state 36


state 60

    (18) create -> DUAL VARIABLE ID .

    NL              reduce using rule 18 (create -> DUAL VARIABLE ID .)
    SEMICOLON       reduce using rule 18 (create -> DUAL VARIABLE ID .)
    COMMA           reduce using rule 18 (create -> DUAL VARIABLE ID .)


state 61

    (19) create -> DUAL VARIABLES idlist .
    (27) idlist -> idlist . ID

    NL              reduce using rule 19 (create -> DUAL VARIABLES idlist .)
    SEMICOLON       reduce using rule 19 (create -> DUAL VARIABLES idlist .)
    COMMA           reduce using rule 19 (create -> DUAL VARIABLES idlist .)
    ID              shift and go to state 98


state 62

    (28) idlist -> ID .

    ID              reduce using rule 28 (idlist -> ID .)
    NL              reduce using rule 28 (idlist -> ID .)
    SEMICOLON       reduce using rule 28 (idlist -> ID .)
    COMMA           reduce using rule 28 (idlist -> ID .)


state 63

    (68) mono -> LPAREN mono RPAREN .

    RPAREN          reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    TIMES           reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    DIVIDE          reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    POWER           reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    NL              reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    SEMICOLON       reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    COMMA           reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    LOGICALEQUAL    reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    GREATERTHANEQUAL reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    LESSTHANEQUAL   reduce using rule 68 (mono -> LPAREN mono RPAREN .)
    PLUS            reduce using rule 68 (mono -> LPAREN mono RPAREN .)


state 64

    (67) posy -> LPAREN posy RPAREN .

    NL              reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    PLUS            reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    TIMES           reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    DIVIDE          reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    POWER           reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    LESSTHANEQUAL   reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    SEMICOLON       reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    COMMA           reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    RPAREN          reduce using rule 67 (posy -> LPAREN posy RPAREN .)
    GREATERTHANEQUAL reduce using rule 67 (posy -> LPAREN posy RPAREN .)


state 65

    (65) posy -> posy DIVIDE mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 65 (posy -> posy DIVIDE mono .)
    PLUS            reduce using rule 65 (posy -> posy DIVIDE mono .)
    TIMES           reduce using rule 65 (posy -> posy DIVIDE mono .)
    DIVIDE          reduce using rule 65 (posy -> posy DIVIDE mono .)
    LESSTHANEQUAL   reduce using rule 65 (posy -> posy DIVIDE mono .)
    SEMICOLON       reduce using rule 65 (posy -> posy DIVIDE mono .)
    COMMA           reduce using rule 65 (posy -> posy DIVIDE mono .)
    RPAREN          reduce using rule 65 (posy -> posy DIVIDE mono .)
    GREATERTHANEQUAL reduce using rule 65 (posy -> posy DIVIDE mono .)
    POWER           shift and go to state 43

  ! POWER           [ reduce using rule 65 (posy -> posy DIVIDE mono .) ]
  ! TIMES           [ shift and go to state 99 ]
  ! DIVIDE          [ shift and go to state 42 ]


state 66

    (68) mono -> LPAREN . mono RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 100

state 67

    (66) posy -> posy POWER INT .

    NL              reduce using rule 66 (posy -> posy POWER INT .)
    PLUS            reduce using rule 66 (posy -> posy POWER INT .)
    TIMES           reduce using rule 66 (posy -> posy POWER INT .)
    DIVIDE          reduce using rule 66 (posy -> posy POWER INT .)
    POWER           reduce using rule 66 (posy -> posy POWER INT .)
    LESSTHANEQUAL   reduce using rule 66 (posy -> posy POWER INT .)
    SEMICOLON       reduce using rule 66 (posy -> posy POWER INT .)
    COMMA           reduce using rule 66 (posy -> posy POWER INT .)
    RPAREN          reduce using rule 66 (posy -> posy POWER INT .)
    GREATERTHANEQUAL reduce using rule 66 (posy -> posy POWER INT .)


state 68

    (48) constraint -> posy LESSTHANEQUAL mono .
    (40) chained_constraint -> posy LESSTHANEQUAL mono . GREATERTHANEQUAL posy
    (43) chained_constraint -> posy LESSTHANEQUAL mono . LOGICALEQUAL mono
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 48 (constraint -> posy LESSTHANEQUAL mono .)
    SEMICOLON       reduce using rule 48 (constraint -> posy LESSTHANEQUAL mono .)
    COMMA           reduce using rule 48 (constraint -> posy LESSTHANEQUAL mono .)
    GREATERTHANEQUAL shift and go to state 101
    LOGICALEQUAL    shift and go to state 102
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 69

    (63) posy -> posy TIMES mono .
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 63 (posy -> posy TIMES mono .)
    PLUS            reduce using rule 63 (posy -> posy TIMES mono .)
    TIMES           reduce using rule 63 (posy -> posy TIMES mono .)
    DIVIDE          reduce using rule 63 (posy -> posy TIMES mono .)
    LESSTHANEQUAL   reduce using rule 63 (posy -> posy TIMES mono .)
    SEMICOLON       reduce using rule 63 (posy -> posy TIMES mono .)
    COMMA           reduce using rule 63 (posy -> posy TIMES mono .)
    RPAREN          reduce using rule 63 (posy -> posy TIMES mono .)
    GREATERTHANEQUAL reduce using rule 63 (posy -> posy TIMES mono .)
    POWER           shift and go to state 43

  ! POWER           [ reduce using rule 63 (posy -> posy TIMES mono .) ]
  ! PLUS            [ shift and go to state 48 ]
  ! TIMES           [ shift and go to state 95 ]
  ! DIVIDE          [ shift and go to state 42 ]


state 70

    (62) posy -> posy TIMES posy .
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    NL              reduce using rule 62 (posy -> posy TIMES posy .)
    PLUS            reduce using rule 62 (posy -> posy TIMES posy .)
    TIMES           reduce using rule 62 (posy -> posy TIMES posy .)
    DIVIDE          reduce using rule 62 (posy -> posy TIMES posy .)
    LESSTHANEQUAL   reduce using rule 62 (posy -> posy TIMES posy .)
    SEMICOLON       reduce using rule 62 (posy -> posy TIMES posy .)
    COMMA           reduce using rule 62 (posy -> posy TIMES posy .)
    RPAREN          reduce using rule 62 (posy -> posy TIMES posy .)
    GREATERTHANEQUAL reduce using rule 62 (posy -> posy TIMES posy .)
    POWER           shift and go to state 36

  ! POWER           [ reduce using rule 62 (posy -> posy TIMES posy .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 35 ]


state 71

    (61) posy -> posy PLUS mono .
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 61 (posy -> posy PLUS mono .)
    PLUS            reduce using rule 61 (posy -> posy PLUS mono .)
    LESSTHANEQUAL   reduce using rule 61 (posy -> posy PLUS mono .)
    SEMICOLON       reduce using rule 61 (posy -> posy PLUS mono .)
    COMMA           reduce using rule 61 (posy -> posy PLUS mono .)
    RPAREN          reduce using rule 61 (posy -> posy PLUS mono .)
    GREATERTHANEQUAL reduce using rule 61 (posy -> posy PLUS mono .)
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43

  ! TIMES           [ reduce using rule 61 (posy -> posy PLUS mono .) ]
  ! DIVIDE          [ reduce using rule 61 (posy -> posy PLUS mono .) ]
  ! POWER           [ reduce using rule 61 (posy -> posy PLUS mono .) ]
  ! PLUS            [ shift and go to state 48 ]


state 72

    (60) posy -> posy PLUS posy .
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    NL              reduce using rule 60 (posy -> posy PLUS posy .)
    PLUS            reduce using rule 60 (posy -> posy PLUS posy .)
    LESSTHANEQUAL   reduce using rule 60 (posy -> posy PLUS posy .)
    SEMICOLON       reduce using rule 60 (posy -> posy PLUS posy .)
    COMMA           reduce using rule 60 (posy -> posy PLUS posy .)
    RPAREN          reduce using rule 60 (posy -> posy PLUS posy .)
    GREATERTHANEQUAL reduce using rule 60 (posy -> posy PLUS posy .)
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 35
    POWER           shift and go to state 36

  ! TIMES           [ reduce using rule 60 (posy -> posy PLUS posy .) ]
  ! DIVIDE          [ reduce using rule 60 (posy -> posy PLUS posy .) ]
  ! POWER           [ reduce using rule 60 (posy -> posy PLUS posy .) ]
  ! PLUS            [ shift and go to state 39 ]


state 73

    (25) dimlist -> INT .

    RPAREN          reduce using rule 25 (dimlist -> INT .)


state 74

    (20) var -> ID LPAREN dimlist . RPAREN

    RPAREN          shift and go to state 103


state 75

    (22) var -> ID LPAREN RPAREN .

    TIMES           reduce using rule 22 (var -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 22 (var -> ID LPAREN RPAREN .)
    POWER           reduce using rule 22 (var -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 22 (var -> ID LPAREN RPAREN .)
    LOGICALEQUAL    reduce using rule 22 (var -> ID LPAREN RPAREN .)
    GREATERTHANEQUAL reduce using rule 22 (var -> ID LPAREN RPAREN .)
    LESSTHANEQUAL   reduce using rule 22 (var -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 22 (var -> ID LPAREN RPAREN .)
    NL              reduce using rule 22 (var -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 22 (var -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 22 (var -> ID LPAREN RPAREN .)
    ID              reduce using rule 22 (var -> ID LPAREN RPAREN .)


state 76

    (26) dimlist -> ID .

    RPAREN          reduce using rule 26 (dimlist -> ID .)


state 77

    (53) mono -> mono DIVIDE mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    RPAREN          reduce using rule 53 (mono -> mono DIVIDE mono .)
    TIMES           reduce using rule 53 (mono -> mono DIVIDE mono .)
    DIVIDE          reduce using rule 53 (mono -> mono DIVIDE mono .)
    NL              reduce using rule 53 (mono -> mono DIVIDE mono .)
    SEMICOLON       reduce using rule 53 (mono -> mono DIVIDE mono .)
    COMMA           reduce using rule 53 (mono -> mono DIVIDE mono .)
    LOGICALEQUAL    reduce using rule 53 (mono -> mono DIVIDE mono .)
    GREATERTHANEQUAL reduce using rule 53 (mono -> mono DIVIDE mono .)
    LESSTHANEQUAL   reduce using rule 53 (mono -> mono DIVIDE mono .)
    PLUS            reduce using rule 53 (mono -> mono DIVIDE mono .)
    POWER           shift and go to state 43

  ! POWER           [ reduce using rule 53 (mono -> mono DIVIDE mono .) ]
  ! TIMES           [ shift and go to state 99 ]
  ! DIVIDE          [ shift and go to state 42 ]


state 78

    (55) mono -> mono POWER INT .

    RPAREN          reduce using rule 55 (mono -> mono POWER INT .)
    TIMES           reduce using rule 55 (mono -> mono POWER INT .)
    DIVIDE          reduce using rule 55 (mono -> mono POWER INT .)
    POWER           reduce using rule 55 (mono -> mono POWER INT .)
    NL              reduce using rule 55 (mono -> mono POWER INT .)
    SEMICOLON       reduce using rule 55 (mono -> mono POWER INT .)
    COMMA           reduce using rule 55 (mono -> mono POWER INT .)
    LOGICALEQUAL    reduce using rule 55 (mono -> mono POWER INT .)
    GREATERTHANEQUAL reduce using rule 55 (mono -> mono POWER INT .)
    LESSTHANEQUAL   reduce using rule 55 (mono -> mono POWER INT .)
    PLUS            reduce using rule 55 (mono -> mono POWER INT .)


state 79

    (54) mono -> mono POWER FLOAT .

    RPAREN          reduce using rule 54 (mono -> mono POWER FLOAT .)
    TIMES           reduce using rule 54 (mono -> mono POWER FLOAT .)
    DIVIDE          reduce using rule 54 (mono -> mono POWER FLOAT .)
    POWER           reduce using rule 54 (mono -> mono POWER FLOAT .)
    NL              reduce using rule 54 (mono -> mono POWER FLOAT .)
    SEMICOLON       reduce using rule 54 (mono -> mono POWER FLOAT .)
    COMMA           reduce using rule 54 (mono -> mono POWER FLOAT .)
    LOGICALEQUAL    reduce using rule 54 (mono -> mono POWER FLOAT .)
    GREATERTHANEQUAL reduce using rule 54 (mono -> mono POWER FLOAT .)
    LESSTHANEQUAL   reduce using rule 54 (mono -> mono POWER FLOAT .)
    PLUS            reduce using rule 54 (mono -> mono POWER FLOAT .)


state 80

    (50) constraint -> mono LESSTHANEQUAL mono .
    (45) chained_constraint -> mono LESSTHANEQUAL mono . GREATERTHANEQUAL mono
    (46) chained_constraint -> mono LESSTHANEQUAL mono . LESSTHANEQUAL mono
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy

    NL              reduce using rule 50 (constraint -> mono LESSTHANEQUAL mono .)
    SEMICOLON       reduce using rule 50 (constraint -> mono LESSTHANEQUAL mono .)
    COMMA           reduce using rule 50 (constraint -> mono LESSTHANEQUAL mono .)
    GREATERTHANEQUAL shift and go to state 105
    LESSTHANEQUAL   shift and go to state 104
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43
    PLUS            shift and go to state 48


state 81

    (44) chained_constraint -> mono LESSTHANEQUAL posy . GREATERTHANEQUAL mono
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    GREATERTHANEQUAL shift and go to state 106
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 35
    POWER           shift and go to state 36


state 82

    (51) constraint -> mono GREATERTHANEQUAL mono .
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 51 (constraint -> mono GREATERTHANEQUAL mono .)
    SEMICOLON       reduce using rule 51 (constraint -> mono GREATERTHANEQUAL mono .)
    COMMA           reduce using rule 51 (constraint -> mono GREATERTHANEQUAL mono .)
    PLUS            shift and go to state 48
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 83

    (49) constraint -> mono GREATERTHANEQUAL posy .
    (41) chained_constraint -> mono GREATERTHANEQUAL posy . LESSTHANEQUAL mono
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    NL              reduce using rule 49 (constraint -> mono GREATERTHANEQUAL posy .)
    SEMICOLON       reduce using rule 49 (constraint -> mono GREATERTHANEQUAL posy .)
    COMMA           reduce using rule 49 (constraint -> mono GREATERTHANEQUAL posy .)
    LESSTHANEQUAL   shift and go to state 107
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 35
    POWER           shift and go to state 36


state 84

    (52) mono -> mono TIMES mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy

    LOGICALEQUAL    reduce using rule 52 (mono -> mono TIMES mono .)
    GREATERTHANEQUAL reduce using rule 52 (mono -> mono TIMES mono .)
    LESSTHANEQUAL   reduce using rule 52 (mono -> mono TIMES mono .)
    TIMES           reduce using rule 52 (mono -> mono TIMES mono .)
    DIVIDE          reduce using rule 52 (mono -> mono TIMES mono .)
    PLUS            reduce using rule 52 (mono -> mono TIMES mono .)
    RPAREN          reduce using rule 52 (mono -> mono TIMES mono .)
    NL              reduce using rule 52 (mono -> mono TIMES mono .)
    SEMICOLON       reduce using rule 52 (mono -> mono TIMES mono .)
    COMMA           reduce using rule 52 (mono -> mono TIMES mono .)
    POWER           shift and go to state 43

  ! POWER           [ reduce using rule 52 (mono -> mono TIMES mono .) ]
  ! TIMES           [ shift and go to state 46 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! PLUS            [ shift and go to state 48 ]


state 85

    (64) posy -> mono TIMES posy .
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    NL              reduce using rule 64 (posy -> mono TIMES posy .)
    PLUS            reduce using rule 64 (posy -> mono TIMES posy .)
    TIMES           reduce using rule 64 (posy -> mono TIMES posy .)
    DIVIDE          reduce using rule 64 (posy -> mono TIMES posy .)
    LESSTHANEQUAL   reduce using rule 64 (posy -> mono TIMES posy .)
    SEMICOLON       reduce using rule 64 (posy -> mono TIMES posy .)
    COMMA           reduce using rule 64 (posy -> mono TIMES posy .)
    RPAREN          reduce using rule 64 (posy -> mono TIMES posy .)
    GREATERTHANEQUAL reduce using rule 64 (posy -> mono TIMES posy .)
    POWER           shift and go to state 36

  ! POWER           [ reduce using rule 64 (posy -> mono TIMES posy .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 35 ]


state 86

    (47) constraint -> mono LOGICALEQUAL mono .
    (42) chained_constraint -> mono LOGICALEQUAL mono . GREATERTHANEQUAL posy
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 47 (constraint -> mono LOGICALEQUAL mono .)
    SEMICOLON       reduce using rule 47 (constraint -> mono LOGICALEQUAL mono .)
    COMMA           reduce using rule 47 (constraint -> mono LOGICALEQUAL mono .)
    GREATERTHANEQUAL shift and go to state 108
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 87

    (59) posy -> mono PLUS mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 59 (posy -> mono PLUS mono .)
    PLUS            reduce using rule 59 (posy -> mono PLUS mono .)
    LESSTHANEQUAL   reduce using rule 59 (posy -> mono PLUS mono .)
    SEMICOLON       reduce using rule 59 (posy -> mono PLUS mono .)
    COMMA           reduce using rule 59 (posy -> mono PLUS mono .)
    RPAREN          reduce using rule 59 (posy -> mono PLUS mono .)
    GREATERTHANEQUAL reduce using rule 59 (posy -> mono PLUS mono .)
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43

  ! TIMES           [ reduce using rule 59 (posy -> mono PLUS mono .) ]
  ! DIVIDE          [ reduce using rule 59 (posy -> mono PLUS mono .) ]
  ! POWER           [ reduce using rule 59 (posy -> mono PLUS mono .) ]


state 88

    (23) varlist -> varlist var .

    ID              reduce using rule 23 (varlist -> varlist var .)
    NL              reduce using rule 23 (varlist -> varlist var .)
    SEMICOLON       reduce using rule 23 (varlist -> varlist var .)
    COMMA           reduce using rule 23 (varlist -> varlist var .)


state 89

    (35) statements -> statements statement SEMICOLON NL .

    CVX_END         reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    VARIABLE        reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    VARIABLES       reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    DUAL            reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    INT             reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    FLOAT           reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    LPAREN          reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    ID              reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    NL              reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    SEMICOLON       reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    COMMA           reduce using rule 35 (statements -> statements statement SEMICOLON NL .)
    SENSE           reduce using rule 35 (statements -> statements statement SEMICOLON NL .)


state 90

    (1) program -> cvxbegin statements objective statements cvxend .

    $end            reduce using rule 1 (program -> cvxbegin statements objective statements cvxend .)


state 91

    (15) cvxend -> CVX_END COMMA .

    $end            reduce using rule 15 (cvxend -> CVX_END COMMA .)


state 92

    (13) cvxend -> CVX_END NL .

    $end            reduce using rule 13 (cvxend -> CVX_END NL .)


state 93

    (14) cvxend -> CVX_END SEMICOLON .

    $end            reduce using rule 14 (cvxend -> CVX_END SEMICOLON .)


state 94

    (7) objective -> SENSE mono NL .
    (8) objective -> SENSE mono NL . SUBJECT TO NL

    CVX_END         reduce using rule 7 (objective -> SENSE mono NL .)
    VARIABLE        reduce using rule 7 (objective -> SENSE mono NL .)
    VARIABLES       reduce using rule 7 (objective -> SENSE mono NL .)
    DUAL            reduce using rule 7 (objective -> SENSE mono NL .)
    INT             reduce using rule 7 (objective -> SENSE mono NL .)
    FLOAT           reduce using rule 7 (objective -> SENSE mono NL .)
    LPAREN          reduce using rule 7 (objective -> SENSE mono NL .)
    ID              reduce using rule 7 (objective -> SENSE mono NL .)
    NL              reduce using rule 7 (objective -> SENSE mono NL .)
    SEMICOLON       reduce using rule 7 (objective -> SENSE mono NL .)
    COMMA           reduce using rule 7 (objective -> SENSE mono NL .)
    SUBJECT         shift and go to state 109


state 95

    (64) posy -> mono TIMES . posy
    (52) mono -> mono TIMES . mono
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 58
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 110
    posy                           shift and go to state 85

state 96

    (68) mono -> LPAREN mono . RPAREN
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    RPAREN          shift and go to state 63
    PLUS            shift and go to state 48
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 97

    (5) objective -> SENSE posy NL .
    (6) objective -> SENSE posy NL . SUBJECT TO NL

    CVX_END         reduce using rule 5 (objective -> SENSE posy NL .)
    VARIABLE        reduce using rule 5 (objective -> SENSE posy NL .)
    VARIABLES       reduce using rule 5 (objective -> SENSE posy NL .)
    DUAL            reduce using rule 5 (objective -> SENSE posy NL .)
    INT             reduce using rule 5 (objective -> SENSE posy NL .)
    FLOAT           reduce using rule 5 (objective -> SENSE posy NL .)
    LPAREN          reduce using rule 5 (objective -> SENSE posy NL .)
    ID              reduce using rule 5 (objective -> SENSE posy NL .)
    NL              reduce using rule 5 (objective -> SENSE posy NL .)
    SEMICOLON       reduce using rule 5 (objective -> SENSE posy NL .)
    COMMA           reduce using rule 5 (objective -> SENSE posy NL .)
    SUBJECT         shift and go to state 111


state 98

    (27) idlist -> idlist ID .

    ID              reduce using rule 27 (idlist -> idlist ID .)
    NL              reduce using rule 27 (idlist -> idlist ID .)
    SEMICOLON       reduce using rule 27 (idlist -> idlist ID .)
    COMMA           reduce using rule 27 (idlist -> idlist ID .)


state 99

    (52) mono -> mono TIMES . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 112

state 100

    (68) mono -> LPAREN mono . RPAREN
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    RPAREN          shift and go to state 63
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 101

    (40) chained_constraint -> posy LESSTHANEQUAL mono GREATERTHANEQUAL . posy
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 58
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 113
    posy                           shift and go to state 114

state 102

    (43) chained_constraint -> posy LESSTHANEQUAL mono LOGICALEQUAL . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 115

state 103

    (20) var -> ID LPAREN dimlist RPAREN .

    TIMES           reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    DIVIDE          reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    POWER           reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    PLUS            reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    LOGICALEQUAL    reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    GREATERTHANEQUAL reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    LESSTHANEQUAL   reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    RPAREN          reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    NL              reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    SEMICOLON       reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    COMMA           reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)
    ID              reduce using rule 20 (var -> ID LPAREN dimlist RPAREN .)


state 104

    (46) chained_constraint -> mono LESSTHANEQUAL mono LESSTHANEQUAL . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 116

state 105

    (45) chained_constraint -> mono LESSTHANEQUAL mono GREATERTHANEQUAL . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 117

state 106

    (44) chained_constraint -> mono LESSTHANEQUAL posy GREATERTHANEQUAL . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 118

state 107

    (41) chained_constraint -> mono GREATERTHANEQUAL posy LESSTHANEQUAL . mono
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    LPAREN          shift and go to state 66
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 119

state 108

    (42) chained_constraint -> mono LOGICALEQUAL mono GREATERTHANEQUAL . posy
    (59) posy -> . mono PLUS mono
    (60) posy -> . posy PLUS posy
    (61) posy -> . posy PLUS mono
    (62) posy -> . posy TIMES posy
    (63) posy -> . posy TIMES mono
    (64) posy -> . mono TIMES posy
    (65) posy -> . posy DIVIDE mono
    (66) posy -> . posy POWER INT
    (67) posy -> . LPAREN posy RPAREN
    (52) mono -> . mono TIMES mono
    (53) mono -> . mono DIVIDE mono
    (54) mono -> . mono POWER FLOAT
    (55) mono -> . mono POWER INT
    (56) mono -> . var
    (57) mono -> . INT
    (58) mono -> . FLOAT
    (68) mono -> . LPAREN mono RPAREN
    (20) var -> . ID LPAREN dimlist RPAREN
    (21) var -> . ID
    (22) var -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 58
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    ID              shift and go to state 16

    var                            shift and go to state 10
    mono                           shift and go to state 113
    posy                           shift and go to state 120

state 109

    (8) objective -> SENSE mono NL SUBJECT . TO NL

    TO              shift and go to state 121


state 110

    (52) mono -> mono TIMES mono .
    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    PLUS            reduce using rule 52 (mono -> mono TIMES mono .)
    TIMES           reduce using rule 52 (mono -> mono TIMES mono .)
    DIVIDE          reduce using rule 52 (mono -> mono TIMES mono .)
    NL              reduce using rule 52 (mono -> mono TIMES mono .)
    SEMICOLON       reduce using rule 52 (mono -> mono TIMES mono .)
    COMMA           reduce using rule 52 (mono -> mono TIMES mono .)
    LESSTHANEQUAL   reduce using rule 52 (mono -> mono TIMES mono .)
    RPAREN          reduce using rule 52 (mono -> mono TIMES mono .)
    GREATERTHANEQUAL reduce using rule 52 (mono -> mono TIMES mono .)
    POWER           shift and go to state 43

  ! POWER           [ reduce using rule 52 (mono -> mono TIMES mono .) ]
  ! PLUS            [ shift and go to state 48 ]
  ! TIMES           [ shift and go to state 95 ]
  ! DIVIDE          [ shift and go to state 42 ]


state 111

    (6) objective -> SENSE posy NL SUBJECT . TO NL

    TO              shift and go to state 122


state 112

    (52) mono -> mono TIMES mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    RPAREN          reduce using rule 52 (mono -> mono TIMES mono .)
    TIMES           reduce using rule 52 (mono -> mono TIMES mono .)
    DIVIDE          reduce using rule 52 (mono -> mono TIMES mono .)
    NL              reduce using rule 52 (mono -> mono TIMES mono .)
    SEMICOLON       reduce using rule 52 (mono -> mono TIMES mono .)
    COMMA           reduce using rule 52 (mono -> mono TIMES mono .)
    LOGICALEQUAL    reduce using rule 52 (mono -> mono TIMES mono .)
    GREATERTHANEQUAL reduce using rule 52 (mono -> mono TIMES mono .)
    LESSTHANEQUAL   reduce using rule 52 (mono -> mono TIMES mono .)
    PLUS            reduce using rule 52 (mono -> mono TIMES mono .)
    POWER           shift and go to state 43

  ! POWER           [ reduce using rule 52 (mono -> mono TIMES mono .) ]
  ! TIMES           [ shift and go to state 99 ]
  ! DIVIDE          [ shift and go to state 42 ]


state 113

    (59) posy -> mono . PLUS mono
    (64) posy -> mono . TIMES posy
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    PLUS            shift and go to state 48
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 114

    (40) chained_constraint -> posy LESSTHANEQUAL mono GREATERTHANEQUAL posy .
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    NL              reduce using rule 40 (chained_constraint -> posy LESSTHANEQUAL mono GREATERTHANEQUAL posy .)
    SEMICOLON       reduce using rule 40 (chained_constraint -> posy LESSTHANEQUAL mono GREATERTHANEQUAL posy .)
    COMMA           reduce using rule 40 (chained_constraint -> posy LESSTHANEQUAL mono GREATERTHANEQUAL posy .)
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 35
    POWER           shift and go to state 36


state 115

    (43) chained_constraint -> posy LESSTHANEQUAL mono LOGICALEQUAL mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 43 (chained_constraint -> posy LESSTHANEQUAL mono LOGICALEQUAL mono .)
    SEMICOLON       reduce using rule 43 (chained_constraint -> posy LESSTHANEQUAL mono LOGICALEQUAL mono .)
    COMMA           reduce using rule 43 (chained_constraint -> posy LESSTHANEQUAL mono LOGICALEQUAL mono .)
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 116

    (46) chained_constraint -> mono LESSTHANEQUAL mono LESSTHANEQUAL mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 46 (chained_constraint -> mono LESSTHANEQUAL mono LESSTHANEQUAL mono .)
    SEMICOLON       reduce using rule 46 (chained_constraint -> mono LESSTHANEQUAL mono LESSTHANEQUAL mono .)
    COMMA           reduce using rule 46 (chained_constraint -> mono LESSTHANEQUAL mono LESSTHANEQUAL mono .)
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 117

    (45) chained_constraint -> mono LESSTHANEQUAL mono GREATERTHANEQUAL mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 45 (chained_constraint -> mono LESSTHANEQUAL mono GREATERTHANEQUAL mono .)
    SEMICOLON       reduce using rule 45 (chained_constraint -> mono LESSTHANEQUAL mono GREATERTHANEQUAL mono .)
    COMMA           reduce using rule 45 (chained_constraint -> mono LESSTHANEQUAL mono GREATERTHANEQUAL mono .)
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 118

    (44) chained_constraint -> mono LESSTHANEQUAL posy GREATERTHANEQUAL mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 44 (chained_constraint -> mono LESSTHANEQUAL posy GREATERTHANEQUAL mono .)
    SEMICOLON       reduce using rule 44 (chained_constraint -> mono LESSTHANEQUAL posy GREATERTHANEQUAL mono .)
    COMMA           reduce using rule 44 (chained_constraint -> mono LESSTHANEQUAL posy GREATERTHANEQUAL mono .)
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 119

    (41) chained_constraint -> mono GREATERTHANEQUAL posy LESSTHANEQUAL mono .
    (52) mono -> mono . TIMES mono
    (53) mono -> mono . DIVIDE mono
    (54) mono -> mono . POWER FLOAT
    (55) mono -> mono . POWER INT

    NL              reduce using rule 41 (chained_constraint -> mono GREATERTHANEQUAL posy LESSTHANEQUAL mono .)
    SEMICOLON       reduce using rule 41 (chained_constraint -> mono GREATERTHANEQUAL posy LESSTHANEQUAL mono .)
    COMMA           reduce using rule 41 (chained_constraint -> mono GREATERTHANEQUAL posy LESSTHANEQUAL mono .)
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 42
    POWER           shift and go to state 43


state 120

    (42) chained_constraint -> mono LOGICALEQUAL mono GREATERTHANEQUAL posy .
    (60) posy -> posy . PLUS posy
    (61) posy -> posy . PLUS mono
    (62) posy -> posy . TIMES posy
    (63) posy -> posy . TIMES mono
    (65) posy -> posy . DIVIDE mono
    (66) posy -> posy . POWER INT

    NL              reduce using rule 42 (chained_constraint -> mono LOGICALEQUAL mono GREATERTHANEQUAL posy .)
    SEMICOLON       reduce using rule 42 (chained_constraint -> mono LOGICALEQUAL mono GREATERTHANEQUAL posy .)
    COMMA           reduce using rule 42 (chained_constraint -> mono LOGICALEQUAL mono GREATERTHANEQUAL posy .)
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 35
    POWER           shift and go to state 36


state 121

    (8) objective -> SENSE mono NL SUBJECT TO . NL

    NL              shift and go to state 123


state 122

    (6) objective -> SENSE posy NL SUBJECT TO . NL

    NL              shift and go to state 124


state 123

    (8) objective -> SENSE mono NL SUBJECT TO NL .

    CVX_END         reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    VARIABLE        reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    VARIABLES       reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    DUAL            reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    INT             reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    FLOAT           reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    LPAREN          reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    ID              reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    NL              reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    SEMICOLON       reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)
    COMMA           reduce using rule 8 (objective -> SENSE mono NL SUBJECT TO NL .)


state 124

    (6) objective -> SENSE posy NL SUBJECT TO NL .

    CVX_END         reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    VARIABLE        reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    VARIABLES       reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    DUAL            reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    INT             reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    FLOAT           reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    LPAREN          reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    ID              reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    NL              reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    SEMICOLON       reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)
    COMMA           reduce using rule 6 (objective -> SENSE posy NL SUBJECT TO NL .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NL in state 53 resolved as shift
